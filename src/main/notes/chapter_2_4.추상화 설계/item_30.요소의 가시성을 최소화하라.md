아이템 30. 요소의 가시성을 최소화하라
=========================
작은 인터페이스는 배우기 쉽고 유지하기도 쉬우며, 기능이 많은 클래스보다 적은 클래스가 유지보수가 쉽다.
어떤 수정을 하기 위해서는 클래스 전체를 이해해야 하는데, 요소 자체가 적다면 유지보수하고 테스트할 것이 적기 때문이다.

클래스의 상태를 나타내는 프로퍼티를 외부에서 변경할 수 있다면 클래스는 자신의 상태를 보장할 수 없다.
클래스가 만족해야 하는 클래스의 상태에 대한 규악 등이 있을 수 있다. 
이러한 규악을 모르는 사람은 클래스의 상태를 마음대로 변경할 수 있으므로, 클래스이 불변성이 무너질 가능이 있다.

```kotlin
class CounterSet<T>(
    private val innerSet: MutableSEt<T> = setOf()
) : MutableSet<T> by innerSet {
    
    var elementsAdded: Int = 0
        private set
}
```
세터만 private로 만드는 코드는 굉장히 많다.
일반적으로 코틀린에서는 이처럼 구체 접근자의 가시성을 제한해서 모든 프로퍼티를 캡슐화하는 것이 좋다.
서로서로 의존하는 프로퍼티가 있을 때는 객체 상태를 보호하는 것이 더 중요하다.

```kotlin
class MutableLazyHolder<T>(val initializer: () -> T) {
    
    private var value: Any = Any()
    private var initialized = false
    
    override fun get(): T {
        if (!initialized) {
            value = initializer()
            initialized = true
        }
        
        return value as T
    }
    
    override fun setValue() {
        this.value = value
        initialized = true
    }
}
```

가시성이 제한될수록 클래스 변경을 쉽게 추적할 수 있으며 프로퍼티 상태를 더 쉽게 이해할 수 있다. 이는 동시성을 처리할 때 중요하다.

### 가시성 한정자 사용하기
내부 변경 없이 작은 인터페이스를 유지하고 싶다면 가시성을 제한하면 된다. 가시성 제한은 가기성 한정자를 활용해서 구현한다.

#### 가시성 한정자
* public(디폴트) : 어디서나 볼 수 있음
* private : 클래스 안에서만 볼 수 있음
* protected : 클래스, 서브클래스 내부에서만 볼 수 있음
* internal : 모듈 내부에서만 볼 수 있다

#### 톱레벨 요소에서의 가시성 한정자
* public(디폴트) : 어디서나 볼 수 있음
* private : 같은 파일 안에서만 볼 수 있음
* internal : 모듈 내부에서만 볼 수 있음

코틀린에서 모듈이란 함께 컴파일되는 코틀린 소스를 의미한다.

이러한 규칙은 데이터를 저장하도록 설계된 클래스(데이터 모델 클래스, DTO)에는 적용하지 않는 게 좋다. 
데이터를 저장하게 설계된 클래스는 숨길 이유가 없기 때문이다. 
따라서 프로퍼티를 쓸 수 있게 눈에 띄게 만드는 게 좋으며 필요하지 않은 경우 그냥 제거하는 게 좋다.

한 가지 제한은 API 상속 시 오버라이드해서 가시성을 제한할 수는 없다. 
이는 서브클래스가 슈퍼클래스로도 쓰일 수 있기 때문이다. 이게 상속보다 컴포지션을 선호하는 대표적인 이유다.

### 정리
요소의 가시성은 최대한 제한적인 것이 좋다.
* 인터페이스가 작을수록 이를 공부하고 유지하는 것이 쉽다.
* 최대한 제한이 되어 있어야 변경하기 쉽다.
* 클래스의 상태를 나타내는 프로퍼티가 노출되어 있다면, 클래스가 자신의 상태를 책임질 수 없다.
* 가시성이 제한되면 API의 변경을 쉽게 추적할 수 있다.